import pandas as pd
from datetime import datetime
from logistics import calculate_distance, estimate_co2_savings

# --- CONFIGURATION ---
INVENTORY_FILE = 'data/mock_inventory.csv'
NGO_FILE = 'data/mock_ngos.csv'

# --- CORE FUNCTIONS ---

def calculate_freshness(stock_date_str, expiry_date_str):
    """
    Calculates the freshness of an item as a percentage (0-100).

    Args:
        stock_date_str (str): The date the item was stocked (ISO format).
        expiry_date_str (str): The date the item expires (ISO format).

    Returns:
        float: The freshness score from 0 to 100.
    """
    stock_date = datetime.fromisoformat(stock_date_str).date()
    expiry_date = datetime.fromisoformat(expiry_date_str).date()
    current_date = datetime.now().date()

    if current_date >= expiry_date:
        return 0.0

    total_shelf_life = (expiry_date - stock_date).days
    days_remaining = (expiry_date - current_date).days

    if total_shelf_life <= 0:
        return 0.0

    freshness_score = (days_remaining / total_shelf_life) * 100
    return max(0, min(freshness_score, 100)) # Ensure score is between 0 and 100

def find_best_matches(item, ngos_df):
    """
    Finds the best NGO matches for a given item based on category, location, and distance.

    Args:
        item (pd.Series): A pandas Series object representing the item to redistribute.
        ngos_df (pd.DataFrame): A DataFrame containing all NGO data.

    Returns:
        list: A sorted list of dictionaries, where each dictionary is a matched NGO
              with an added 'distance_km' and 'match_score'.
    """
    # 1. Filter NGOs that accept the item's category
    compatible_ngos = ngos_df[ngos_df['accepted_categories'].str.contains(item['category'])]

    if compatible_ngos.empty:
        return []

    # 2. Calculate distance, CO2 savings, and a match score for each compatible NGO
    matches = []
    for _, ngo in compatible_ngos.iterrows():
        dist = calculate_distance(
            item['latitude'], item['longitude'],
            ngo['latitude'], ngo['longitude']
        )
        co2_saved = estimate_co2_savings(dist)
        
        # Score prioritizes closer NGOs. Add a small epsilon to avoid division by zero.
        match_score = 1 / (dist + 1e-6)

        ngo_match = ngo.to_dict()
        ngo_match['distance_km'] = round(dist, 2)
        ngo_match['co2_savings_kg'] = co2_saved
        ngo_match['match_score'] = round(match_score, 4)
        matches.append(ngo_match)

    # 3. Sort matches by score in descending order
    matches.sort(key=lambda x: x['match_score'], reverse=True)

    return matches

# --- MAIN CLASS (ENGINE) ---

class RedistributionEngine:
    def __init__(self):
        """Initializes the engine by loading the datasets."""
        print("Initializing Redistribution Engine...")
        try:
            self.inventory_df = pd.read_csv(INVENTORY_FILE)
            self.ngos_df = pd.read_csv(NGO_FILE)
            print("Datasets loaded successfully.")
        except FileNotFoundError as e:
            print(f"Error loading data: {e}")
            print("Please ensure mock data has been generated by running `ml/data_generation.py`")
            self.inventory_df = pd.DataFrame()
            self.ngos_df = pd.DataFrame()

    def get_redistribution_candidates(self, freshness_threshold=20.0):
        """
        Identifies all items in the inventory that are below the freshness threshold.
        
        Args:
            freshness_threshold (float): The freshness percentage below which an item
                                         is considered a candidate for redistribution.
        
        Returns:
            pd.DataFrame: A DataFrame of items that need redistribution.
        """
        if self.inventory_df.empty:
            return pd.DataFrame()

        # Calculate freshness for all items
        self.inventory_df['freshness'] = self.inventory_df.apply(
            lambda row: calculate_freshness(row['stock_date'], row['expiry_date']),
            axis=1
        )

        # Filter for items below the threshold
        candidates = self.inventory_df[self.inventory_df['freshness'] < freshness_threshold].copy()
        return candidates.sort_values(by='freshness', ascending=True)

    def run_engine_for_item(self, product_id):
        """
        Runs the full redistribution logic for a single product ID.
        
        Args:
            product_id (str): The ID of the product to process.
            
        Returns:
            tuple: A tuple containing the item's details and a list of matched NGOs,
                   or (None, []) if the item is not found or not a candidate.
        """
        item = self.inventory_df[self.inventory_df['product_id'] == product_id].iloc[0]
        
        # Recalculate freshness in case it hasn't been done
        item_freshness = calculate_freshness(item['stock_date'], item['expiry_date'])
        
        if item_freshness >= 20.0:
            print(f"Item {product_id} has a freshness of {item_freshness:.2f}% and does not need redistribution.")
            return item.to_dict(), []
            
        print(f"Finding matches for item {product_id} (Freshness: {item_freshness:.2f}%)")
        matches = find_best_matches(item, self.ngos_df)
        
        return item.to_dict(), matches

# --- EXAMPLE USAGE ---

if __name__ == '__main__':
    engine = RedistributionEngine()

    # Example 1: Get all items that are candidates for redistribution
    print("\n--- Finding all redistribution candidates (freshness < 20%) ---")
    candidates_df = engine.get_redistribution_candidates(freshness_threshold=20.0)
    print(f"Found {len(candidates_df)} items needing redistribution.")
    if not candidates_df.empty:
        print(candidates_df.head())

    # Example 2: Run the engine for a specific item from the candidates list
    if not candidates_df.empty:
        sample_item_id = candidates_df.iloc[0]['product_id']
        print(f"\n--- Running engine for a sample item: {sample_item_id} ---")
        
        item_details, top_matches = engine.run_engine_for_item(sample_item_id)
        
        if top_matches:
            print(f"Top 3 matches for {item_details['product_name']} at store {item_details['store_id']}:")
            for match in top_matches[:3]:
                print(
                    f"  - NGO: {match['ngo_name']} ({match['location']})"
                    f" | Distance: {match['distance_km']} km"
                    f" | CO2 Saved: {match['co2_savings_kg']} kg"
                    f" | Capacity: {match['capacity_kg']} kg"
                )
        else:
            print("No compatible NGOs found for this item.")